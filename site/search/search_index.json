{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Graph Neural Network Cancer Drug Response (gnnCDR) A major goal in precision oncology is to match a patient and tumor to the optimal therapeutic treatment. Research towards these goals include identifying drug combinations or repurposing drugs used in other domains to address limitations in oncology treatment durability, drug resistance and patient toxicity. We seek to accelerate and improve drug development by developing algorithms that improve how we identify therapeutic drug combinations based on \u2018omic features and improve predictions of drug response. Project Summary Ineffective or limited precision oncology treatments are a cause of patient mortality. We seek to address this challenge by improving pre-clinical drug repurposing and drug combination discovery. We highlight the methodological challenge of training drug response models using single-drug data that will generalize well to multi-drug perturbations. We operate on the premise that protein-protein interactions mediate cellular drug response and hypothesize that incorporating this prior knowledge in a deep learning framework is liable to overcome limitations in drug response modeling and enable novel approaches to drug prioritization. To do this we will predict drug perturbed mRNA expression from intrinsic cancer features using graph neural networks that operate on literature curated protein-protein and drug-target interactions. In preliminary research, we have developed a synthetic data generator, which we have used to show promise and feasibility of our approach. We will develop and evaluate our methods using synthetic data before applying it to cancer cell line drug-perturbed mRNA expression datasets to prioritize drug combinations. Therapeutic candidates will be empirically evaluated in Dr. Gordon Mills\u2019 and Dr. Jeffrey Tyner\u2019s labs. Successful implementation of our methods will enable tractable and robust drug prioritization based on nuanced therapeutic goals such as user-defined cell type selective response. Premise ... Model Overview Drug Prioritization","title":"Home"},{"location":"#graph-neural-network-cancer-drug-response-gnncdr","text":"A major goal in precision oncology is to match a patient and tumor to the optimal therapeutic treatment. Research towards these goals include identifying drug combinations or repurposing drugs used in other domains to address limitations in oncology treatment durability, drug resistance and patient toxicity. We seek to accelerate and improve drug development by developing algorithms that improve how we identify therapeutic drug combinations based on \u2018omic features and improve predictions of drug response.","title":"Graph Neural Network Cancer Drug Response (gnnCDR)"},{"location":"#project-summary","text":"Ineffective or limited precision oncology treatments are a cause of patient mortality. We seek to address this challenge by improving pre-clinical drug repurposing and drug combination discovery. We highlight the methodological challenge of training drug response models using single-drug data that will generalize well to multi-drug perturbations. We operate on the premise that protein-protein interactions mediate cellular drug response and hypothesize that incorporating this prior knowledge in a deep learning framework is liable to overcome limitations in drug response modeling and enable novel approaches to drug prioritization. To do this we will predict drug perturbed mRNA expression from intrinsic cancer features using graph neural networks that operate on literature curated protein-protein and drug-target interactions. In preliminary research, we have developed a synthetic data generator, which we have used to show promise and feasibility of our approach. We will develop and evaluate our methods using synthetic data before applying it to cancer cell line drug-perturbed mRNA expression datasets to prioritize drug combinations. Therapeutic candidates will be empirically evaluated in Dr. Gordon Mills\u2019 and Dr. Jeffrey Tyner\u2019s labs. Successful implementation of our methods will enable tractable and robust drug prioritization based on nuanced therapeutic goals such as user-defined cell type selective response.","title":"Project Summary"},{"location":"#premise","text":"...","title":"Premise"},{"location":"#model-overview","text":"","title":"Model Overview"},{"location":"#drug-prioritization","text":"","title":"Drug Prioritization"},{"location":"data/","text":"Data Overview Synthetic Data GeneNetWeaver (GNW) GNW-L1000 ... Real Data LICNS L1000 DepMap Reactome FI CMAP drug data","title":"Data Overview"},{"location":"data/#data-overview","text":"","title":"Data Overview"},{"location":"data/#synthetic-data","text":"","title":"Synthetic Data"},{"location":"data/#genenetweaver-gnw","text":"","title":"GeneNetWeaver (GNW)"},{"location":"data/#gnw-l1000","text":"...","title":"GNW-L1000"},{"location":"data/#real-data","text":"","title":"Real Data"},{"location":"data/#licns-l1000","text":"","title":"LICNS L1000"},{"location":"data/#depmap","text":"","title":"DepMap"},{"location":"data/#reactome-fi","text":"","title":"Reactome FI"},{"location":"data/#cmap-drug-data","text":"","title":"CMAP drug data"},{"location":"pages_usage/mkdocs_guides/","text":"Links to mkdocs guides Material General Toc Material Color Palette","title":"Mkdocs Help"},{"location":"pages_usage/mkdocs_guides/#links-to-mkdocs-guides","text":"","title":"Links to mkdocs guides"},{"location":"pages_usage/mkdocs_guides/#material","text":"General Toc Material Color Palette","title":"Material"},{"location":"pages_usage/syntax_examples/","text":"List of random syntax examples Downloading Data download_abcd_batch.sh - Script to call NDA downloader download.py - NDA downloader (Fair Lab) . File Path Func ./ download_abcd_batch.sh docs Script to call NDA downloader ../../ download.py docs NDA data downloader Name Required Details Python Markdown Yes Python Markdown must be installed as it is the Markdown parser that is being used. Pygments (optional) No If Pygments Syntax highlighting is desired, Pygments must be installed. This can be omitted, and code blocks will be formatted for use with JavaScript code highlighters. Autoembed table from csv ??? note \"Dynamically embedding a table from a .csv\" === \"Adding a new table\" This is syntax to ad a new table === \"Syntax\" | col1 | col2 | col3 | col4 | col5 | col6 | col7 | |-------:|-------:|-------:|-------:|-------:|-------:|-------:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 4 | 5 | 6 | 7 | 8 | 9 | 10 | | 7 | 8 | 9 | 10 | 11 | 12 | 13 | === \"output\" | col1 | col2 | col3 | col4 | col5 | col6 | col7 | |-------:|-------:|-------:|-------:|-------:|-------:|-------:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 4 | 5 | 6 | 7 | 8 | 9 | 10 | | 7 | 8 | 9 | 10 | 11 | 12 | 13 | ### Add entire script --8<-- \"file1.ext\" \"file2.ext\" --8<-- Code snippets add line numer and highlight lines 2 and language linenums=\"1\" hl_lines=\"2 3\" ??? bug pycon3 linenums=\"1\" hl_lines=\"2 3\" >>> import markdown >>> text = \"A link https://google.com\" >>> html = markdown.markdown(text, extensions=['pymdownx.magiclink']) ??? note === \"Output\" Task List - [X] item 1 * [X] item A * [ ] item B more text + [x] item a + [ ] item b + [x] item c * [X] item C - [ ] item 2 - [ ] item 3 === \"Markdown\" ``` Task List - [X] item 1 * [X] item A * [ ] item B more text + [x] item a + [ ] item b + [x] item c * [X] item C - [ ] item 2 - [ ] item 3 ``` !!! note test test for note !!! todo test test for note !!! tldr test test for note !!! important test test for note !!! done test test for note !!! faq test test for note !!! attention test test for note !!! error test test for note !!! bug test test for note !!! quote test test for note !!! reminder I still need to download the data ???+ failure Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. ??? example \"Inline Highlighted Code Example\" === \"Output\" Here is some code: `#!py3 import pymdownx; pymdownx.__version__` The mock shebang will be treated like text here: ` #!js var test = 0; `. === \"Markdown\" ``` Here is some code: `#!py3 import pymdownx; pymdownx.__version__`. The mock shebang will be treated like text here: ` #!js var test = 0; `. ``` The mock shebang will be treated like text here: #!js var test = 0; . srun $PYTHON_ENV download.py \\ -i $manifest \\ -o $outdir \\ -s $sublist \\ -l $logfiles \\ -d $subset -p 6 import pandas as pd import numpy as np def test_func(var1, var2): return x Clinical Data data_subsets.txt - List of derivatives subject_list.txt - List of subjects","title":"Mkdocs Syntax"},{"location":"pages_usage/syntax_examples/#list-of-random-syntax-examples","text":"","title":"List of random syntax examples"},{"location":"pages_usage/syntax_examples/#downloading-data","text":"download_abcd_batch.sh - Script to call NDA downloader download.py - NDA downloader (Fair Lab) . File Path Func ./ download_abcd_batch.sh docs Script to call NDA downloader ../../ download.py docs NDA data downloader Name Required Details Python Markdown Yes Python Markdown must be installed as it is the Markdown parser that is being used. Pygments (optional) No If Pygments Syntax highlighting is desired, Pygments must be installed. This can be omitted, and code blocks will be formatted for use with JavaScript code highlighters.","title":"Downloading Data"},{"location":"pages_usage/syntax_examples/#autoembed-table-from-csv","text":"??? note \"Dynamically embedding a table from a .csv\" === \"Adding a new table\" This is syntax to ad a new table === \"Syntax\" | col1 | col2 | col3 | col4 | col5 | col6 | col7 | |-------:|-------:|-------:|-------:|-------:|-------:|-------:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 4 | 5 | 6 | 7 | 8 | 9 | 10 | | 7 | 8 | 9 | 10 | 11 | 12 | 13 | === \"output\" | col1 | col2 | col3 | col4 | col5 | col6 | col7 | |-------:|-------:|-------:|-------:|-------:|-------:|-------:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 4 | 5 | 6 | 7 | 8 | 9 | 10 | | 7 | 8 | 9 | 10 | 11 | 12 | 13 | ### Add entire script --8<-- \"file1.ext\" \"file2.ext\" --8<--","title":"Autoembed table from csv"},{"location":"pages_usage/syntax_examples/#code-snippets","text":"add line numer and highlight lines 2 and language linenums=\"1\" hl_lines=\"2 3\" ??? bug pycon3 linenums=\"1\" hl_lines=\"2 3\" >>> import markdown >>> text = \"A link https://google.com\" >>> html = markdown.markdown(text, extensions=['pymdownx.magiclink']) ??? note === \"Output\" Task List - [X] item 1 * [X] item A * [ ] item B more text + [x] item a + [ ] item b + [x] item c * [X] item C - [ ] item 2 - [ ] item 3 === \"Markdown\" ``` Task List - [X] item 1 * [X] item A * [ ] item B more text + [x] item a + [ ] item b + [x] item c * [X] item C - [ ] item 2 - [ ] item 3 ``` !!! note test test for note !!! todo test test for note !!! tldr test test for note !!! important test test for note !!! done test test for note !!! faq test test for note !!! attention test test for note !!! error test test for note !!! bug test test for note !!! quote test test for note !!! reminder I still need to download the data ???+ failure Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. ??? example \"Inline Highlighted Code Example\" === \"Output\" Here is some code: `#!py3 import pymdownx; pymdownx.__version__` The mock shebang will be treated like text here: ` #!js var test = 0; `. === \"Markdown\" ``` Here is some code: `#!py3 import pymdownx; pymdownx.__version__`. The mock shebang will be treated like text here: ` #!js var test = 0; `. ``` The mock shebang will be treated like text here: #!js var test = 0; . srun $PYTHON_ENV download.py \\ -i $manifest \\ -o $outdir \\ -s $sublist \\ -l $logfiles \\ -d $subset -p 6 import pandas as pd import numpy as np def test_func(var1, var2): return x","title":"Code snippets"},{"location":"pages_usage/syntax_examples/#clinical-data","text":"data_subsets.txt - List of derivatives subject_list.txt - List of subjects","title":"Clinical Data"},{"location":"synth_data/data_obj/","text":"The Synthetic gnnCDR data object Now that we've generated synthetic data, we need to organize it in a format conducive to graph neural networks . We will use pytorch_geometric to build our deep learning models, and use the HeteroData object to structure the training data. We will format our synthetic data as a heterogenous graph with 6 node types: protein agonist inhibitor KO (knockout) KD (knockdown) OE (overexpression) and 7 edge types: - (agonist, targets, protein) - (inhibitor, targets, protein) - (KO, targets, protein) - (KD, targets, protein) - (OE, targets, protein) - (protein, activates, protein) - (protein, inhibits, protein) The genetic nodes do not have any node attributes and only target a single protein. The chemical perturbations have concentration node attributes ( conc ) and can target multiple protein nodes. Protein-protein edges can be of two types: \"activate\" and \"inhibit\". This is illustrated in figure 1 below. Figure 1 : Graphic of our HeteroData object. For programatic simplicity, we have opted to include all perturbation nodes in each observation graph, and specify active perturbations with non-zero node attributes. For chemical perturbations (agonist, inhibitor) this node attribute represents concentration. For genetic perturbations (KO, KD, OE), we use a arbitrary non-zero value of 1 to specify an active perturbation. HeteroSynthDataset Object We extend the pytorch_geometric Dataset object and create a HeteroSynthDataset which functions to parse the synthetic hdf5 file and produce individual observations of the form described above. The perturbation indexing remains the same across all observations. A dataset object can be initialized by: dataset = SynthHeteroDataset('../../data/synthetic_data.h5', indices=None, zscore=False, x_noise=None, y_noise=None, x_sparsity=None, y_sparsity=None, ppi_false=None, dti_false=None, ppi_missing=None, dti_missing=None, seed=None) Passing an array of integers to indices (indexed by the synthetic_data.h5 ) will specfy what data will be included in the dataset. This can be used to specify train/test splits or filter observations. Here are two examples of a returned data object. perturbation: agonist_2 HeteroData( line=[1], context=[1, 10], time=[1], baseline=[1, 100], y=[1, 100], pert_all=[1, 88], pert_name=[1], conc=[1], pert_type=[1], protein={ x=[100, 1], y=[100, 1], num_nodes=100 }, KO={ x=[26, 1], num_nodes=26 }, KD={ x=[26, 1], num_nodes=26 }, OE={ x=[26, 1], }, ... (inhibitor, targets, protein)={ edge_index=[2, 18], edge_attr=[18, 1] } )","title":"The Synthetic gnnCDR Data Object"},{"location":"synth_data/data_obj/#the-synthetic-gnncdr-data-object","text":"Now that we've generated synthetic data, we need to organize it in a format conducive to graph neural networks . We will use pytorch_geometric to build our deep learning models, and use the HeteroData object to structure the training data. We will format our synthetic data as a heterogenous graph with 6 node types: protein agonist inhibitor KO (knockout) KD (knockdown) OE (overexpression) and 7 edge types: - (agonist, targets, protein) - (inhibitor, targets, protein) - (KO, targets, protein) - (KD, targets, protein) - (OE, targets, protein) - (protein, activates, protein) - (protein, inhibits, protein) The genetic nodes do not have any node attributes and only target a single protein. The chemical perturbations have concentration node attributes ( conc ) and can target multiple protein nodes. Protein-protein edges can be of two types: \"activate\" and \"inhibit\". This is illustrated in figure 1 below. Figure 1 : Graphic of our HeteroData object. For programatic simplicity, we have opted to include all perturbation nodes in each observation graph, and specify active perturbations with non-zero node attributes. For chemical perturbations (agonist, inhibitor) this node attribute represents concentration. For genetic perturbations (KO, KD, OE), we use a arbitrary non-zero value of 1 to specify an active perturbation.","title":"The Synthetic gnnCDR data object"},{"location":"synth_data/data_obj/#heterosynthdataset-object","text":"We extend the pytorch_geometric Dataset object and create a HeteroSynthDataset which functions to parse the synthetic hdf5 file and produce individual observations of the form described above. The perturbation indexing remains the same across all observations. A dataset object can be initialized by: dataset = SynthHeteroDataset('../../data/synthetic_data.h5', indices=None, zscore=False, x_noise=None, y_noise=None, x_sparsity=None, y_sparsity=None, ppi_false=None, dti_false=None, ppi_missing=None, dti_missing=None, seed=None) Passing an array of integers to indices (indexed by the synthetic_data.h5 ) will specfy what data will be included in the dataset. This can be used to specify train/test splits or filter observations. Here are two examples of a returned data object. perturbation: agonist_2 HeteroData( line=[1], context=[1, 10], time=[1], baseline=[1, 100], y=[1, 100], pert_all=[1, 88], pert_name=[1], conc=[1], pert_type=[1], protein={ x=[100, 1], y=[100, 1], num_nodes=100 }, KO={ x=[26, 1], num_nodes=26 }, KD={ x=[26, 1], num_nodes=26 }, OE={ x=[26, 1], }, ... (inhibitor, targets, protein)={ edge_index=[2, 18], edge_attr=[18, 1] } )","title":"HeteroSynthDataset Object"},{"location":"synth_data/data_split/","text":"Creating the Train-Test-Validation datasets We will create three datasets, train : ALL genetic perturbations + a proportion of single agents test : a proportion of single agent data validation : This will be combination data only. Single-agent Datasets The Train and Test splits will only have single-agent perturbations. Since our model attempts to learn drug-specific parameters (binding affinity information) we can not exculde a drug entirely for the training dataset. Instead, we will group observations by cell-line + drug pairs and separate them into either train or test datasets. This allows us to train drug-specific parameters while still testing on unseen cell-line responses. This procedure is illustrated in figure 1. Combination-agent Dataset The validation set will include only chemical combination-agent data. Performance on this data subset is the ultimate goal of our project.","title":"Creating Train/Test/Val Datasets"},{"location":"synth_data/data_split/#creating-the-train-test-validation-datasets","text":"We will create three datasets, train : ALL genetic perturbations + a proportion of single agents test : a proportion of single agent data validation : This will be combination data only.","title":"Creating the Train-Test-Validation datasets"},{"location":"synth_data/data_split/#single-agent-datasets","text":"The Train and Test splits will only have single-agent perturbations. Since our model attempts to learn drug-specific parameters (binding affinity information) we can not exculde a drug entirely for the training dataset. Instead, we will group observations by cell-line + drug pairs and separate them into either train or test datasets. This allows us to train drug-specific parameters while still testing on unseen cell-line responses. This procedure is illustrated in figure 1.","title":"Single-agent Datasets"},{"location":"synth_data/data_split/#combination-agent-dataset","text":"The validation set will include only chemical combination-agent data. Performance on this data subset is the ultimate goal of our project.","title":"Combination-agent Dataset"},{"location":"synth_data/generation/","text":"Synthetic Data Model We use the GeneNetWeaver package to simulate synthetic data Figure 1 : GeneNetWeaver graphic from the original paper. We focus on package elements illustrated by section B. source . To simulate data for initial model training and evaluation, we have extended the GeneNetWeaver package (1) , which uses ordinary differential equations (ODEs) built from a gene regulatory network (GRN) to simulate bulk mRNA gene expression under a variety of conditions. GNW outputs include: cell line steady state gene expression in the absence of any perturbation and gene expression time series after the introduction of genetic or chemical perturbation. GNW uses ODEs of the form: \\[ \\frac{dx_i}{dt} = m_i f_i(y) - \\lambda_i^{RNA} x_i \\] \\[ \\frac{dy_i}{dt} = r_i x_i - \\lambda_i^{PROT} y_i \\] Where \\(x_i\\) is RNA gene expression. \\(y_i\\) is protein abundance. \\(m_i\\) and \\(r_i\\) are production rates. \\(f_i(y)\\) is a function of transcription factor activation and \\(\\lambda\\) represents respective degradation rates. Subscript \\(i\\) represents the respective gene index. Building upon the GNW method, we simulate knockout\u2019s (KO) by setting to zero, knockdown\u2019s (KD) by setting to half its original value and over-expression (OE) by setting to twice it\u2019s original value. Chemical perturbations are simulated by randomly sampling a set of gene targets and respective dissociation constants and modifying the target gene values according to the equation: \\[ m_i^{perturbed} = m_i \\pm \\frac{m_i}{1+\\frac{k_d}{c}} \\] Where \\(k_d\\) represents dissociation constant and c is concentration in micro-molars. We simulate multi-drug combinations by modifying the union of drug targets. Drug target collisions are handled by either... Same drug types (2-agent combination): $$ m_i^{perturberd} = m \\pm m_i * \\frac{c_1}{c_1 + k_{d,1}(1 + \\frac{c_2}{k_{d,2}})} $$ Different drug types (2-agent combination): $$ m_i^{perturberd} = \\frac{m_i^{agonist} + m_i^{inhibitor}}{2} $$ We note the accepted scientific premise of pharmacological binding is that a drug binds to protein and stabilizes an active or inactive conformation. This premise suggests that a logical extension would be the modification of protein abundance or transcription factor activation; However, in practice we find that our approach to drug simulation creates reasonable outputs and captures many aspects of true drug perturbation behavior. Different cell contexts (such as cell type, patient, disease, etc.) have varying GRNs, which result in unique expression steady states and perturbation response. To emulate this behavior, we simulate each cellular context by creating a similar - but distinct \u2013 GRN prior to GNW simulation. Cellular context GRNs are created by randomly removing a subset of edges from the original parent GRN. This modified GRN becomes input to the GNW simulation. This work provides a tool for simulating the LINCS L1000 datatypes. Importantly, the data produced by this method is mediated by an underlying GRN, which makes graph-based methods uniquely suited to modeling the data. Generating Synthetic Data For a detailed walk-through of synthetic data pipeline, see gnnCDR/examples/gnw_tutorial.ipynb Settings Modify the local settings.txt file, which must be stored in the .../gnnCDR/gnn_cdr/gnw/gnw/settings.txt The relevant parameters to modify include... # ideal-waddle Relevant parameters # Default max duration time in time-series experiments (must be consistent with numTimePoints_ and dt_) maxtTimeSeries = 500 # Time step for the time series (numTimePoints_ = (int) Math.round(maxtTimeSeries/dt) + 1) dt = 50 # Number of cell line models to create (n-1 single gene KO models + original) n_cell_lines = 10 # probability of edge removal when making cell line models prob_remove = 0.1 # Graph name to use as base PPI network # InSilicoSize100-Ecoli1.tsv graph_name = InSilicoSize100-Ecoli1.tsv # Number of agonist drugs to create num_agonists = 5 # Number of inhibitor drugs to create num_inhibitors = 5 # minimum concentration to use for drug simulations, intended to be in units log10(uM) min_log_conc = -5 # max conc \"\"\" max_log_conc = 1 # number of concentrations to simulate, spread evenly from min_log_conc to max_log_conc on a log scale num_dose_pts = 5 # The expectation (mean) of the number of targets each drug has. Targets are assigned probabalistically so some will have more and some will have fewer. expected_targs = 2 # minimum dissociation constant (kd) value to assign to drug targets (units of log(uM)) min_kd = -3 # max binding affinity max_kd = 0 Usage To simulate data and produce the desired hdf5 file, navigate to the scripts directory and run: (gnnCDR) $ python create_synthetic_data.py --gnw_cwd ../gnn_cdr/gnw/gnw/ --out ../synthetic_data.h5 For command line options, use --help . Output The resulting hdf5 file will have the following general structure: ################################################## Printing HDF5 output structure. ################################################## baseline <HDF5 dataset \"cell_lines\": shape (25,), type \"|S12\"> <HDF5 dataset \"expr\": shape (25, 100), type \"<f8\"> graphs PPI <HDF5 dataset \"edge_attr\": shape (125, 2), type \"<f8\"> <HDF5 dataset \"edge_index\": shape (2, 125), type \"<i4\"> <HDF5 dataset \"edge_labels\": shape (2,), type \"|O\"> PTI <HDF5 dataset \"binding_affinity\": shape (120,), type \"<f8\"> <HDF5 dataset \"edge_attr\": shape (120, 5), type \"<i8\"> <HDF5 dataset \"edge_index\": shape (2, 120), type \"<i8\"> <HDF5 dataset \"edge_labels\": shape (5,), type \"|O\"> labels <HDF5 dataset \"drug_names\": shape (88,), type \"|S11\"> <HDF5 dataset \"gene_names\": shape (100,), type \"|S4\"> meta cell_models <HDF5 dataset \"cell_line_0\": shape (9, 2), type \"|S3\"> <HDF5 dataset \"cell_line_1\": shape (10, 2), type \"|S3\"> ... <HDF5 dataset \"cell_line_8\": shape (7, 2), type \"|S3\"> <HDF5 dataset \"cell_line_9\": shape (5, 2), type \"|S3\"> <HDF5 dataset \"cell_models_info\": shape (1,), type \"|S54\"> <HDF5 dataset \"creation_date\": shape (), type \"|O\"> edgelist <HDF5 dataset \"annot\": shape (125,), type \"|S1\"> <HDF5 dataset \"from\": shape (125,), type \"|S3\"> <HDF5 dataset \"to\": shape (125,), type \"|S4\"> <HDF5 dataset \"settings\": shape (), type \"|O\"> perts <HDF5 dataset \"cell_line\": shape (344850,), type \"|S12\"> <HDF5 dataset \"conc_um\": shape (344850,), type \"|S46\"> <HDF5 dataset \"expr\": shape (344850, 100), type \"<f8\"> <HDF5 dataset \"pert_kd\": shape (344850,), type \"|S260\"> <HDF5 dataset \"pert_name\": shape (344850,), type \"|S24\"> <HDF5 dataset \"pert_targ\": shape (344850,), type \"|S58\"> <HDF5 dataset \"pert_type\": shape (344850,), type \"|S20\"> <HDF5 dataset \"time\": shape (344850,), type \"<f8\"> Output PCA (left) Colored by cell context (middle) colored by perturbation type, filtered to genetic perturbations only. (right) colored by time. References Schaffter T, Marbach D, Floreano D. GeneNetWeaver: in silico benchmark generation and performance profiling of network inference methods. Bioinformatics. 2011 Aug 15;27(16):2263-70. doi: 10.1093/bioinformatics/btr373. Epub 2011 Jun 22. PMID: 21697125.","title":"Generating a Synthetic Dataset"},{"location":"synth_data/generation/#synthetic-data-model","text":"We use the GeneNetWeaver package to simulate synthetic data Figure 1 : GeneNetWeaver graphic from the original paper. We focus on package elements illustrated by section B. source . To simulate data for initial model training and evaluation, we have extended the GeneNetWeaver package (1) , which uses ordinary differential equations (ODEs) built from a gene regulatory network (GRN) to simulate bulk mRNA gene expression under a variety of conditions. GNW outputs include: cell line steady state gene expression in the absence of any perturbation and gene expression time series after the introduction of genetic or chemical perturbation. GNW uses ODEs of the form: \\[ \\frac{dx_i}{dt} = m_i f_i(y) - \\lambda_i^{RNA} x_i \\] \\[ \\frac{dy_i}{dt} = r_i x_i - \\lambda_i^{PROT} y_i \\] Where \\(x_i\\) is RNA gene expression. \\(y_i\\) is protein abundance. \\(m_i\\) and \\(r_i\\) are production rates. \\(f_i(y)\\) is a function of transcription factor activation and \\(\\lambda\\) represents respective degradation rates. Subscript \\(i\\) represents the respective gene index. Building upon the GNW method, we simulate knockout\u2019s (KO) by setting to zero, knockdown\u2019s (KD) by setting to half its original value and over-expression (OE) by setting to twice it\u2019s original value. Chemical perturbations are simulated by randomly sampling a set of gene targets and respective dissociation constants and modifying the target gene values according to the equation: \\[ m_i^{perturbed} = m_i \\pm \\frac{m_i}{1+\\frac{k_d}{c}} \\] Where \\(k_d\\) represents dissociation constant and c is concentration in micro-molars. We simulate multi-drug combinations by modifying the union of drug targets. Drug target collisions are handled by either... Same drug types (2-agent combination): $$ m_i^{perturberd} = m \\pm m_i * \\frac{c_1}{c_1 + k_{d,1}(1 + \\frac{c_2}{k_{d,2}})} $$ Different drug types (2-agent combination): $$ m_i^{perturberd} = \\frac{m_i^{agonist} + m_i^{inhibitor}}{2} $$ We note the accepted scientific premise of pharmacological binding is that a drug binds to protein and stabilizes an active or inactive conformation. This premise suggests that a logical extension would be the modification of protein abundance or transcription factor activation; However, in practice we find that our approach to drug simulation creates reasonable outputs and captures many aspects of true drug perturbation behavior. Different cell contexts (such as cell type, patient, disease, etc.) have varying GRNs, which result in unique expression steady states and perturbation response. To emulate this behavior, we simulate each cellular context by creating a similar - but distinct \u2013 GRN prior to GNW simulation. Cellular context GRNs are created by randomly removing a subset of edges from the original parent GRN. This modified GRN becomes input to the GNW simulation. This work provides a tool for simulating the LINCS L1000 datatypes. Importantly, the data produced by this method is mediated by an underlying GRN, which makes graph-based methods uniquely suited to modeling the data.","title":"Synthetic Data Model"},{"location":"synth_data/generation/#generating-synthetic-data","text":"For a detailed walk-through of synthetic data pipeline, see gnnCDR/examples/gnw_tutorial.ipynb","title":"Generating Synthetic Data"},{"location":"synth_data/generation/#settings","text":"Modify the local settings.txt file, which must be stored in the .../gnnCDR/gnn_cdr/gnw/gnw/settings.txt The relevant parameters to modify include... # ideal-waddle Relevant parameters # Default max duration time in time-series experiments (must be consistent with numTimePoints_ and dt_) maxtTimeSeries = 500 # Time step for the time series (numTimePoints_ = (int) Math.round(maxtTimeSeries/dt) + 1) dt = 50 # Number of cell line models to create (n-1 single gene KO models + original) n_cell_lines = 10 # probability of edge removal when making cell line models prob_remove = 0.1 # Graph name to use as base PPI network # InSilicoSize100-Ecoli1.tsv graph_name = InSilicoSize100-Ecoli1.tsv # Number of agonist drugs to create num_agonists = 5 # Number of inhibitor drugs to create num_inhibitors = 5 # minimum concentration to use for drug simulations, intended to be in units log10(uM) min_log_conc = -5 # max conc \"\"\" max_log_conc = 1 # number of concentrations to simulate, spread evenly from min_log_conc to max_log_conc on a log scale num_dose_pts = 5 # The expectation (mean) of the number of targets each drug has. Targets are assigned probabalistically so some will have more and some will have fewer. expected_targs = 2 # minimum dissociation constant (kd) value to assign to drug targets (units of log(uM)) min_kd = -3 # max binding affinity max_kd = 0","title":"Settings"},{"location":"synth_data/generation/#usage","text":"To simulate data and produce the desired hdf5 file, navigate to the scripts directory and run: (gnnCDR) $ python create_synthetic_data.py --gnw_cwd ../gnn_cdr/gnw/gnw/ --out ../synthetic_data.h5 For command line options, use --help .","title":"Usage"},{"location":"synth_data/generation/#output","text":"The resulting hdf5 file will have the following general structure: ################################################## Printing HDF5 output structure. ################################################## baseline <HDF5 dataset \"cell_lines\": shape (25,), type \"|S12\"> <HDF5 dataset \"expr\": shape (25, 100), type \"<f8\"> graphs PPI <HDF5 dataset \"edge_attr\": shape (125, 2), type \"<f8\"> <HDF5 dataset \"edge_index\": shape (2, 125), type \"<i4\"> <HDF5 dataset \"edge_labels\": shape (2,), type \"|O\"> PTI <HDF5 dataset \"binding_affinity\": shape (120,), type \"<f8\"> <HDF5 dataset \"edge_attr\": shape (120, 5), type \"<i8\"> <HDF5 dataset \"edge_index\": shape (2, 120), type \"<i8\"> <HDF5 dataset \"edge_labels\": shape (5,), type \"|O\"> labels <HDF5 dataset \"drug_names\": shape (88,), type \"|S11\"> <HDF5 dataset \"gene_names\": shape (100,), type \"|S4\"> meta cell_models <HDF5 dataset \"cell_line_0\": shape (9, 2), type \"|S3\"> <HDF5 dataset \"cell_line_1\": shape (10, 2), type \"|S3\"> ... <HDF5 dataset \"cell_line_8\": shape (7, 2), type \"|S3\"> <HDF5 dataset \"cell_line_9\": shape (5, 2), type \"|S3\"> <HDF5 dataset \"cell_models_info\": shape (1,), type \"|S54\"> <HDF5 dataset \"creation_date\": shape (), type \"|O\"> edgelist <HDF5 dataset \"annot\": shape (125,), type \"|S1\"> <HDF5 dataset \"from\": shape (125,), type \"|S3\"> <HDF5 dataset \"to\": shape (125,), type \"|S4\"> <HDF5 dataset \"settings\": shape (), type \"|O\"> perts <HDF5 dataset \"cell_line\": shape (344850,), type \"|S12\"> <HDF5 dataset \"conc_um\": shape (344850,), type \"|S46\"> <HDF5 dataset \"expr\": shape (344850, 100), type \"<f8\"> <HDF5 dataset \"pert_kd\": shape (344850,), type \"|S260\"> <HDF5 dataset \"pert_name\": shape (344850,), type \"|S24\"> <HDF5 dataset \"pert_targ\": shape (344850,), type \"|S58\"> <HDF5 dataset \"pert_type\": shape (344850,), type \"|S20\"> <HDF5 dataset \"time\": shape (344850,), type \"<f8\">","title":"Output"},{"location":"synth_data/generation/#output-pca","text":"(left) Colored by cell context (middle) colored by perturbation type, filtered to genetic perturbations only. (right) colored by time.","title":"Output PCA"},{"location":"synth_data/generation/#references","text":"Schaffter T, Marbach D, Floreano D. GeneNetWeaver: in silico benchmark generation and performance profiling of network inference methods. Bioinformatics. 2011 Aug 15;27(16):2263-70. doi: 10.1093/bioinformatics/btr373. Epub 2011 Jun 22. PMID: 21697125.","title":"References"}]}